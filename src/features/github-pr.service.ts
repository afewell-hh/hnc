/**
 * GitHub Pull Request service for FGD changes
 * Creates throwaway branches and PRs with FGD YAML files
 * Uses existing GitHubProvider patterns and integrates with feature flags
 */

import { Octokit } from '@octokit/rest'
import { isGhPrEnabled } from './feature-flags.js'
import type { WiringDiagram } from '../app.types.js'
import { serializeWiringDiagram } from '../io/yaml.js'

export interface GitHubPRConfig {
  token: string
  remote: string // e.g., 'https://github.com/owner/repo.git' or 'owner/repo'
  baseBranch?: string // default: 'main'
}

export interface GitHubPRResult {
  success: boolean
  prUrl?: string
  prNumber?: number
  branchName?: string
  error?: string
}

export interface PRPayload {
  title: string
  body: string
  head: string
  base: string
  labels?: string[]
}

export class GitHubPRService {
  private octokit: Octokit | null = null
  private owner: string = ''
  private repo: string = ''
  
  constructor(private config: GitHubPRConfig) {
    this.parseRemote()
  }

  /**
   * Initialize the service with Octokit client
   */
  async initialize(): Promise<boolean> {
    if (!isGhPrEnabled()) {
      return false
    }

    try {
      this.octokit = new Octokit({
        auth: this.config.token,
      })
      return true
    } catch (error) {
      console.warn('Failed to initialize GitHub PR service:', error)
      return false
    }
  }

  /**
   * Parse GitHub remote URL to extract owner/repo
   */
  private parseRemote(): void {
    const remote = this.config.remote

    // Handle different remote formats
    if (remote.includes('github.com')) {
      // HTTPS: https://github.com/owner/repo.git
      // SSH: git@github.com:owner/repo.git
      const match = remote.match(/github\.com[:/]([^/]+)\/(.+?)(?:\.git)?$/)
      if (match) {
        this.owner = match[1]
        this.repo = match[2]
        return
      }
    }

    // Simple format: owner/repo
    if (remote.includes('/') && !remote.includes('://')) {
      const parts = remote.split('/')
      if (parts.length >= 2) {
        this.owner = parts[0]
        this.repo = parts[1]
        return
      }
    }

    throw new Error(`Invalid GitHub remote format: ${remote}`)
  }

  /**
   * Create throwaway branch for FGD changes
   * Pattern: hnc-fgd-pr/<fabricId>/<timestamp>
   */
  private createBranchName(fabricId: string): string {
    const timestamp = Date.now()
    return `hnc-fgd-pr/${fabricId}/${timestamp}`
  }

  /**
   * Build PR payload with title, body, and metadata
   */
  buildPRPayload(
    fabricId: string,
    diagram: WiringDiagram,
    branchName: string,
    baseBranch = 'main'
  ): PRPayload {
    const serverCount = diagram.devices.servers.length
    const leafCount = diagram.devices.leaves.length
    const spineCount = diagram.devices.spines.length
    const switchCount = leafCount + spineCount
    
    // Calculate total endpoints
    const endpointCount = diagram.devices.servers.reduce((total, server) => {
      return total + (server.connections || 0)
    }, 0)

    // Calculate diff summary for body
    const yamls = serializeWiringDiagram(diagram)
    const serverLines = yamls.servers.split('\n').length
    const switchLines = yamls.switches.split('\n').length
    const connectionLines = yamls.connections.split('\n').length
    const totalLines = serverLines + switchLines + connectionLines

    const title = `HNC: Save ${fabricId} FGD files`
    
    const body = `## Summary

This PR contains generated FGD (Fabric Generation Data) files for fabric \`${fabricId}\`.

### Configuration
- **Fabric ID**: ${fabricId}
- **Topology**: ${leafCount} leaves, ${spineCount} spines
- **Endpoints**: ${endpointCount} allocated
- **Total devices**: ${serverCount} servers, ${switchCount} switches

### Files Changed
- \`fgd/${fabricId}/servers.yaml\` (${serverLines} lines)
- \`fgd/${fabricId}/switches.yaml\` (${switchLines} lines)  
- \`fgd/${fabricId}/connections.yaml\` (${connectionLines} lines)

**Total**: ${totalLines} lines across 3 YAML files

### Generated by HNC
This PR was automatically generated by the HNC (Hybrid Network Configuration) tool.
The FGD files contain the complete wiring diagram specification ready for deployment.

**⚠️ Note**: This is a throwaway branch for review purposes. Manual approval required before merge.`

    return {
      title,
      body,
      head: branchName,
      base: baseBranch,
      labels: ['hnc', 'fgd']
    }
  }

  /**
   * Create PR with FGD changes
   */
  async createFGDPullRequest(fabricId: string, diagram: WiringDiagram): Promise<GitHubPRResult> {
    if (!this.octokit) {
      return { success: false, error: 'Service not initialized' }
    }

    const branchName = this.createBranchName(fabricId)
    const baseBranch = this.config.baseBranch || 'main'

    try {
      // Get base branch reference
      const baseRef = await this.octokit.git.getRef({
        owner: this.owner,
        repo: this.repo,
        ref: `heads/${baseBranch}`
      })

      // Create new branch
      await this.octokit.git.createRef({
        owner: this.owner,
        repo: this.repo,
        ref: `refs/heads/${branchName}`,
        sha: baseRef.data.object.sha
      })

      // Serialize FGD to YAML
      const yamls = serializeWiringDiagram(diagram)

      // Create directory structure and files
      const files = [
        {
          path: `fgd/${fabricId}/servers.yaml`,
          content: yamls.servers
        },
        {
          path: `fgd/${fabricId}/switches.yaml`,
          content: yamls.switches
        },
        {
          path: `fgd/${fabricId}/connections.yaml`,
          content: yamls.connections
        }
      ]

      // Create blobs for each file
      const blobs = await Promise.all(
        files.map(async (file) => {
          const blob = await this.octokit!.git.createBlob({
            owner: this.owner,
            repo: this.repo,
            content: file.content,
            encoding: 'utf-8'
          })
          return { path: file.path, sha: blob.data.sha }
        })
      )

      // Create tree
      const tree = await this.octokit.git.createTree({
        owner: this.owner,
        repo: this.repo,
        base_tree: baseRef.data.object.sha,
        tree: blobs.map(blob => ({
          path: blob.path,
          mode: '100644',
          type: 'blob',
          sha: blob.sha
        }))
      })

      // Create commit
      const commit = await this.octokit.git.createCommit({
        owner: this.owner,
        repo: this.repo,
        message: `Add FGD files for ${fabricId}

- ${diagram.devices.leaves.length} leaves, ${diagram.devices.spines.length} spines computed
- ${diagram.devices.servers.reduce((total, server) => total + (server.connections || 0), 0)} endpoints allocated
- ${diagram.devices.servers.length} servers, ${diagram.devices.leaves.length + diagram.devices.spines.length} switches total

Generated by HNC GitHub PR mode`,
        tree: tree.data.sha,
        parents: [baseRef.data.object.sha]
      })

      // Update branch reference
      await this.octokit.git.updateRef({
        owner: this.owner,
        repo: this.repo,
        ref: `heads/${branchName}`,
        sha: commit.data.sha
      })

      // Create PR payload
      const payload = this.buildPRPayload(fabricId, diagram, branchName, baseBranch)

      // Create pull request
      const pr = await this.octokit.pulls.create({
        owner: this.owner,
        repo: this.repo,
        ...payload
      })

      // Add labels if specified
      if (payload.labels && payload.labels.length > 0) {
        try {
          await this.octokit.issues.addLabels({
            owner: this.owner,
            repo: this.repo,
            issue_number: pr.data.number,
            labels: payload.labels
          })
        } catch (error) {
          // Label addition is optional, don't fail the whole operation
          console.warn('Failed to add labels to PR:', error)
        }
      }

      return {
        success: true,
        prUrl: pr.data.html_url,
        prNumber: pr.data.number,
        branchName
      }

    } catch (error: any) {
      return {
        success: false,
        error: `Failed to create PR: ${error.message}`
      }
    }
  }

  /**
   * Check if GitHub PR service is available and configured
   */
  static isAvailable(): boolean {
    return isGhPrEnabled() && Boolean(
      process.env.GITHUB_TOKEN && 
      process.env.GIT_REMOTE
    )
  }
}

/**
 * Factory function to create GitHub PR service with environment-based config
 */
export function createGitHubPRService(): GitHubPRService | null {
  if (!GitHubPRService.isAvailable()) {
    return null
  }

  const token = process.env.GITHUB_TOKEN!
  const remote = process.env.GIT_REMOTE!
  
  return new GitHubPRService({
    token,
    remote,
    baseBranch: process.env.GIT_BASE_BRANCH || 'main'
  })
}

/**
 * Check if GitHub PR integration is available
 */
export function isGitHubPRAvailable(): boolean {
  return GitHubPRService.isAvailable()
}