# HNC v0.3.0 Development Plan

## üéØ Mission Statement

Build production-grade switch profile ingestion and intelligent port allocation while maintaining rock-solid test infrastructure achieved in v0.2.0-alpha.

## üìã Scope Definition (Tight, No Yak-Shaving)

### Goals
1. **ONF Switch Profile Ingestion** - Parse `switch_profile.go` ‚Üí synthesize HNC switch profile
2. **Counts-First Port Allocator** - Smart port allocation respecting model constraints (no per-port pinning GUI)
3. **Optional Git Feature Flag** - Read/write capability, off by default, Storybook + unit tests only

### Non-Goals (v0.4+ Deferred)
- Per-port pinning GUI
- Advanced topology visualization
- Real K8s deployment
- Production Git workflow (beyond basic I/O)

## üöÄ Work Packages

### WP-S1: Switch Profile Ingestion
**Objective**: Parse ONF `switch_profile.go` ‚Üí produce normalized JSON profile

**Technical Requirements**:
- Parse Go struct definitions for port ranges, speeds, roles
- Extract switch capabilities (uplink counts, speeds, port density)
- Generate normalized JSON profile schema
- Create validation for profile completeness

**Deliverables**:
- `src/profiles/switch-profile-parser.ts` - Go parser implementation
- `src/profiles/types.ts` - TypeScript interface definitions
- `tools/profile-ingestion.mjs` - CLI tool for batch processing
- `tests/profiles/parser.test.ts` - Comprehensive test coverage

**Acceptance Criteria**:
- Parse DS2000/DS3000 profiles from ONF Go structs
- Generate valid JSON profiles with port capabilities
- 100% test coverage for parser logic
- Storybook stories showing profile visualization

### WP-A1: Counts-First Port Allocator
**Objective**: Intelligent port allocation respecting uplinksPerLeaf constraints

**Technical Requirements**:
- Map endpoint counts ‚Üí legal port sets per model/profile
- Enforce `uplinksPerLeaf % spines == 0` mathematical constraint
- Generate port allocation strategies without GUI assignment
- Integrate with existing compute topology logic

**Deliverables**:
- `src/allocation/port-allocator.ts` - Core allocation engine
- `src/allocation/constraints.ts` - Constraint validation logic
- `src/allocation/strategies.ts` - Allocation strategy implementations
- `tests/allocation/` - Full test suite with edge cases

**Acceptance Criteria**:
- Allocate ports for given endpoint counts and switch profiles
- Respect mathematical constraints (uplinks divisible by spines)
- Generate deterministic allocation results
- Integration with existing FabricDesigner component

### WP-G1: Git Feature Flag Implementation
**Objective**: Git I/O behind feature flag for controlled testing

**Technical Requirements**:
- Feature flag system (`ENABLE_GIT_FEATURES=false` by default)
- Basic read/write operations for YAML files
- Storybook stories showing Git integration states
- Unit tests covering Git operations (mocked)

**Deliverables**:
- `src/features/git.service.ts` - Git service implementation
- `src/features/feature-flags.ts` - Feature flag management
- `stories/Git.stories.tsx` - Git integration stories
- `tests/features/git.test.ts` - Mocked Git operation tests

**Acceptance Criteria**:
- Git operations only active when feature flag enabled
- Read/write YAML files from/to Git repository
- 100% test coverage with mocked Git operations
- Storybook demonstrates enabled/disabled states

## üèóÔ∏è Implementation Strategy

### Phase 1: Foundation (Week 1)
1. Set up WP-S1 infrastructure (parser skeleton, tests)
2. Create basic profile schema and validation
3. Establish Git feature flag architecture

### Phase 2: Core Development (Week 2)
1. Implement switch profile parser for DS2000/DS3000
2. Build port allocator with constraint validation
3. Integrate Git service with feature flags

### Phase 3: Integration (Week 3)
1. Connect allocator with existing topology computation
2. Add Git operations to save/load workflows
3. Create comprehensive Storybook stories

### Phase 4: Quality & Polish (Week 4)
1. Achieve 100% test coverage across all WPs
2. Performance optimization for large profiles
3. Documentation and user guides

## üéØ Success Metrics

### Quantitative Targets
- **Test Coverage**: 100% for all new components
- **Storybook Stories**: 15+ stories covering all major flows
- **Performance**: Profile parsing < 100ms for standard profiles
- **Integration**: Zero regressions in existing v0.2 functionality

### Qualitative Goals
- **Developer Experience**: Clear APIs, good TypeScript support
- **Maintainability**: Modular architecture, clean separation
- **Extensibility**: Easy to add new switch profiles and constraints
- **Documentation**: Comprehensive guides for all new features

## üîó Claude-Flow Command Integration

### Parallel Work Package Execution
```bash
# Initialize all three work packages concurrently
npx claude-flow@alpha hive-mind spawn \
"Implement ONF switch profile parser (WP-S1): Parse switch_profile.go structs, generate JSON profiles, create validation. Deliverables: parser.ts, types.ts, tests, Storybook stories." \
--agents 2 --claude

npx claude-flow@alpha hive-mind spawn \
"Build counts-first port allocator (WP-A1): Intelligent port allocation, constraint validation, integration with topology. Deliverables: allocator.ts, constraints.ts, tests." \
--agents 2 --claude

npx claude-flow@alpha hive-mind spawn \
"Implement Git feature flag system (WP-G1): Feature flags, Git I/O service, Storybook integration. Deliverables: git.service.ts, feature-flags.ts, tests, stories." \
--agents 1 --claude
```

### Quality Assurance Integration
```bash
# Continuous QC validation during development
npx claude-flow@alpha hive-mind spawn \
"Maintain 100% test coverage and QC compliance throughout v0.3 development. Run QC gates, identify test gaps, ensure no regressions from v0.2.0-alpha baseline." \
--agents 1 --claude
```

## üìö Architecture Decisions

### Switch Profile Schema
- **JSON-based**: Portable, version-controllable
- **TypeScript-first**: Strong typing for all profile properties
- **Extensible**: Easy to add new switch models and capabilities
- **Validated**: Runtime validation with detailed error messages

### Port Allocation Strategy
- **Mathematical Constraints**: Enforce uplinks-per-leaf divisibility
- **Model-Aware**: Respect switch port capabilities and speeds
- **Deterministic**: Same inputs produce same allocation results
- **Traceable**: Clear allocation reasoning for debugging

### Git Integration Approach
- **Feature-Flagged**: Off by default, controllable activation
- **Mocked Testing**: Full test coverage without real Git dependencies
- **Storybook Integration**: Visual testing of Git workflows
- **Progressive Enhancement**: Works with/without Git availability

## üö® Risk Mitigation

### Technical Risks
1. **Go Parser Complexity** - Mitigation: Start with simple structs, expand iteratively
2. **Port Allocation Edge Cases** - Mitigation: Comprehensive test suite with mathematical validation
3. **Git Integration Instability** - Mitigation: Feature flags allow safe disabling

### Quality Risks
1. **Test Regression** - Mitigation: QC script integration, continuous validation
2. **Performance Degradation** - Mitigation: Benchmark testing, profile optimization
3. **API Breaking Changes** - Mitigation: Backward compatibility testing

## üìà Post-v0.3 Roadmap Preview

### v0.4: Advanced Topology Features
- Visual topology editor
- Advanced constraint visualization
- Multi-datacenter support

### v0.5: Production Deployment
- Real K8s integration
- Production Git workflows
- Advanced monitoring and alerting

---

**Next Steps**: Ready for Claude-Flow work package initialization using the spawn commands above. Each work package can be executed in parallel with clear deliverables and acceptance criteria.

üöÄ **v0.3.0 Development Ready to Launch!**