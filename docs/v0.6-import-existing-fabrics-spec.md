# HNC v0.6 — Import Existing Fabrics Specification

## Overview
Enable management of already-deployed fabrics by importing existing FGD YAML files and reconstructing editable FabricSpecs. This unlocks "manage what exists" workflows for production operators.

## Work Packets

### WP-IMP1 — FGD → Editable Spec Importer
**Goal**: Parse existing YAML files and reconstruct FabricSpec with import provenance

```typescript
// New domain/fgd-importer.ts
export interface ImportResult {
  success: boolean
  fabricSpec?: FabricSpec
  leafClasses?: LeafClass[]
  issues: ImportIssue[]
  provenance: ProvenanceMap
}

export interface ImportIssue {
  code: string                    // e.g., 'CAPACITY_EXCEEDED', 'UNKNOWN_MODEL'
  severity: 'error' | 'warning' | 'info'
  message: string
  context: { file?: string; device?: string; port?: string }
}

export interface ProvenanceMap {
  [fieldPath: string]: {
    origin: 'auto' | 'user' | 'import'
    source: string              // e.g., 'switches.yaml:spine-1'
    timestamp: string
  }
}
```

**Core Functions**:
```typescript
// Parse YAML files and reconstruct fabric specification
export async function importFromFGD(
  fgdPath: string
): Promise<ImportResult>

// Validate imported spec against current rules
export function validateImportedSpec(
  spec: FabricSpec,
  leafClasses: LeafClass[]
): { errors: ImportIssue[], warnings: ImportIssue[] }

// Merge imported spec with current fabric if editing existing
export function mergeImportedSpec(
  current: FabricSpec,
  imported: FabricSpec,
  strategy: 'overwrite' | 'merge' | 'prompt'
): FabricSpec
```

**Claude-Flow Command**:
```bash
npx claude-flow@alpha hive-mind spawn \
"WP-IMP1: Add FGD importer that reads switches/servers/connections YAML and reconstructs FabricSpec + leaf classes with origin=import. Parse DS2000/DS3000 models, detect multi-class patterns, handle capacity violations. Reverse-engineer spine/leaf counts, uplinks per leaf, endpoint profiles. Unit tests cover happy path, multi-class, capacity exceeded, unknown models. Exit: unit green."
--agents 2 --claude
```

### WP-IMP2 — Conflict Detection + Mapping to Rules Engine
**Goal**: Surface import conflicts through existing Issues panel with Save gating

```typescript
// Enhanced rules engine integration
export interface ImportConflict extends Issue {
  importedValue: any
  expectedValue: any
  recommendedAction: 'accept' | 'reject' | 'modify'
  autoResolvable: boolean
}

// New rule codes for import scenarios
const IMPORT_RULE_CODES = {
  IMPORTED_CAPACITY_EXCEEDED: 'Imported fabric exceeds current switch capacities',
  IMPORTED_INVALID_UPLINKS: 'Imported uplinks not divisible by spine count',
  IMPORTED_UNKNOWN_MODELS: 'Switch/server models not in current catalog',
  IMPORTED_TOPOLOGY_MISMATCH: 'Imported topology doesn\'t match expected pattern',
  IMPORTED_PORT_CONFLICTS: 'Port assignments conflict with current allocations'
}
```

**UI Integration**:
- Issues panel shows "Imported Overrides" section
- Each conflict has Accept/Reject/Modify actions
- Save gating follows existing policy (errors block, warnings allow)
- Override chips show "Import Override" state

**Claude-Flow Command**:
```bash
npx claude-flow@alpha hive-mind spawn \
"WP-IMP2: Add import conflict detection that maps violations to rules engine. Extend Issues panel with 'Imported Overrides' section showing Accept/Reject/Modify actions. Import conflicts get provenance=import and follow existing Save policy (errors block, warnings allow). Add ImportConflict UI components with override chips. Exit: stories + unit green."
--agents 2 --claude
```

### WP-IMP3 — Storybook Import Flows
**Goal**: Visual validation of import scenarios with comprehensive test coverage

**Stories to Create**:
```typescript
// Import / Happy Path
// - Load valid multi-class FGD
// - All switches/servers recognized
// - No conflicts, clean import
// - Save enabled, deterministic re-export

// Import / With Conflicts  
// - Capacity warnings (oversubscribed spine)
// - Unknown model warnings
// - Issues panel shows conflicts
// - Save allowed with warnings

// Import / Invalid (Errors)
// - Missing required files
// - Malformed YAML
// - Impossible topology (negative ports)
// - Save blocked until resolved

// Import / Re-emit Determinism
// - Import → modify → save → import again
// - Hash equality validation
// - No spurious differences
// - Round-trip stability
```

**Claude-Flow Command**:
```bash
npx claude-flow@alpha hive-mind spawn \
"WP-IMP3: Create 4 Storybook import flows: Happy Path (clean import + save), With Conflicts (warnings + issues panel), Invalid (errors block save), Re-emit Determinism (import→modify→save→import, hash equality). Add ImportFabricDialog component with file picker. Use semantic selectors, accessibility compliance. Exit: build-storybook + test-storybook green."
--agents 2 --claude
```

## Integration Architecture

### With Existing v0.5 Features
- **Wiring Generation**: Imported specs can generate new wiring
- **Expert Overrides**: Import provenance integrates with existing provenance tracking  
- **Rules Engine**: Import conflicts use existing validation framework
- **GitHub PR**: Imported changes can create PRs via existing flow

### State Machine Integration
```typescript
// New events for import workflow
type ImportEvent = 
  | { type: 'IMPORT_START'; fgdPath: string }
  | { type: 'IMPORT_SUCCESS'; spec: FabricSpec; issues: ImportIssue[] }
  | { type: 'IMPORT_CONFLICT'; conflicts: ImportConflict[] }
  | { type: 'IMPORT_ERROR'; error: string }
  | { type: 'RESOLVE_CONFLICT'; conflictId: string; action: 'accept' | 'reject' }
  | { type: 'ACCEPT_ALL_IMPORTS' }

// New states
type ImportState = 
  | 'importing'
  | 'import_conflicts' 
  | 'import_ready'
```

### Data Flow
1. **File Selection**: User selects FGD directory or YAML files
2. **Parse & Validate**: Import parser reads YAML → reconstructs FabricSpec
3. **Conflict Detection**: Rules engine validates imported spec
4. **Issue Resolution**: UI surfaces conflicts → user accepts/rejects/modifies
5. **Save Integration**: Resolved spec enters normal save flow
6. **Round-trip Verification**: Re-export should match import (determinism)

## Testing Strategy

### Unit Tests
- **Parser Edge Cases**: Malformed YAML, missing files, unknown models
- **Spec Reconstruction**: Multi-class detection, capacity calculations
- **Conflict Detection**: All import rule codes triggered
- **Provenance Tracking**: origin=import properly set on all fields

### Integration Tests  
- **End-to-End Import**: FGD directory → editable spec → save → FGD
- **Conflict Resolution**: Import with issues → manual resolution → clean re-export
- **Multi-class Round-trip**: Complex fabric → export → import → identical spec

### Property Tests
- **Import Determinism**: Same FGD → same spec (fast-check generated FGDs)
- **Round-trip Stability**: spec → export → import → spec equality
- **Conflict Consistency**: Same violations always produce same conflicts

## Migration & Deployment

1. **v0.6.0-alpha**: WP-IMP1 (core importer)
2. **v0.6.1-alpha**: WP-IMP2 (conflict resolution UI)  
3. **v0.6.2-alpha**: WP-IMP3 (Storybook stories + polish)

## Success Metrics

- Import 90%+ of well-formed FGD directories successfully
- Conflict resolution reduces import errors by 80%
- Round-trip determinism: import → modify → export → re-import = identical
- Zero data loss during import/export cycles
- All Storybook stories pass with semantic selectors

## Example Import Flow

```yaml
# Detected from switches.yaml:
# - 2x DS3000 (spine-1, spine-2) 
# - 4x DS2000 (leaf-web-1, leaf-web-2, leaf-db-1, leaf-db-2)
# 
# Reconstructed FabricSpec:
fabricName: "imported-prod-fabric"
spines: 2
leafClasses: [
  {
    id: "web",
    name: "Web Tier", 
    count: 2,
    uplinksPerLeaf: 4,
    modelId: "DS2000",
    provenance: { origin: "import", source: "switches.yaml" }
  },
  {
    id: "db", 
    name: "Database Tier",
    count: 2,
    uplinksPerLeaf: 4, 
    modelId: "DS2000",
    provenance: { origin: "import", source: "switches.yaml" }
  }
]
```

## Future Extensions (v0.7+)

- **Multi-site Import**: Federated fabric reconstruction
- **Ansible Integration**: Import from network automation YAML
- **Network Discovery**: SNMP-based fabric detection and import
- **Version Control**: Import from Git-managed FGD repositories

## Implementation Order

1. **Start with WP-IMP1** (foundational parser and reconstruction logic)
2. **Follow with WP-IMP2** (conflict detection and UI integration)  
3. **Complete with WP-IMP3** (visual validation and stories)

Each work packet builds incrementally and maintains backward compatibility with existing v0.5 functionality.